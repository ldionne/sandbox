
namespace tag {
    struct acquire;
    struct release;
}

typedef dyno::event<dyno::tagged_ad<tag::acquire>, ...> acquire;

// No need to repeat the whole definition
// When the second argument is used, tagged_as becomes the definition
// of an event. As such, using this form would trigger a compilation
// error when defining an event like above:
//  dyno::event<
//      dyno::tagged_as<tag::release, acquire>, // <-- compilation error
//      dyno::records<...>,
//  >
typedef dyno::tagged_as<tag::release, acquire> release;


struct my_backend {
    thread_local std::ofstream per_thread_events;

    mutex start_and_join_events_mutex;
    std::ofstream start_and_join_events;

    // Now, this is very specific to our application, but we know that we only
    // need to load acquire and release events thread by thread to build the
    // lock graph correctly. In other words, we don't have to order the
    // acquires and releases between different threads. Thus, it is
    // unnecessary to save all the acquire and release events to the same
    // file. Since we save acquire and release events per-thread, we don't
    // need to synchronize the file because it is unique to this thread.
    template <typename Event>
    void save(tag::acquire, Event const& e) {
        typedef typename event_tag<Event>::type event_tag; // == tag::acquire
        typedef typename event_attribute<Event, tag::info_string>::type info_string;
        // etc...

        if (!per_thread_events) {
            per_thread_events.reset(new std::ofstream("file for this thread"));
        }
        *per_thread_events << make_variant(e); // not serialized for simplicity
    }

    // As for the start and join events, we have to load them all at once
    // in the segmentation graph. For this reason, we will simply save them
    // in a file shared by all the threads and use conventional synchronization.
    template <typename Event>
    void save(tag::start, Event const& e) {
        boost::lock_guard<mutex> lock(start_and_join_events_mutex);
        start_and_join_events << make_variant(e); // not serialized for simplicity
    }
};


// When all the events and the backend are defined, we can create a framework.
typedef dyno::framework<
            dyno::events<acquire, release>,
            dyno::backend<my_backend>
        > d2_framework;


// note: generate() should not have to deal with events. dealing with
//       arbitrary taggables instead of events should do the trick, yet
//       it makes the concept requirements smaller. also, arbitrary types
//       should do the trick for representing the tags of computations.
//       actually, generate() should not be aware that an event will
//       perform computations.

// note2: We should maybe generalize computations so that an event does
//        not have to 'hold' computations, which makes no sense. i think
//        something like 'Information' is a concept that would be more
//        suited. Then, we can have Information that performs a computation
//        in order to be obtained, and information that is externally
//        provided, which makes more sense. We could get rid of the
//        not-quite-right `externally` evaluation policy. However, we
//        should __not__ call the concept Information, which is WAYY
//        too general to mean something. I am sure there is a name that
//        represents exactly what I am thinking about. self-note: Data is
//        not any better than Information.


typedef dyno::event<
    tagged_as<tag::my_event>,
    trigger<
        some_action(tag_of_info_to_pass, other_tag,
                    dyno::special_tag_representing_the_framework_like_in_proto,
                    dyno::special_tag_representing_all_the_args_like_in_proto)
    >
> my_event;


typedef dyno::framework<
            events<my_event>
        > my_framework1;

typedef dyno::bind_to<
            tag::my_event, this_action(dyno::whole_event)
        > framework_with_additional_action_triggered_when_my_event_is_generated;

dyno::enable_dynamic_binding_for<tag::my_event, framework> framework_with_dynamic_binding;

{
    dyno::framework_modifier fm(MY_FRAMEWORK);
    // modify it freely... gotta <3 RAII
}


/*********** COULD THIS BE USEFUL OR IS IT JUST OUT OF LINE? **************/

// Any object can be tracked by dyno. Since the only thing shared by all
// objects is creation and destruction, they are the only lifetime points
// that can reasonably be defined by dyno.
//
// Arbitrary custom events can be attached to the entity.
// This allows to typecheck that the only events that will be generated by an
// entity are those supported by that entity.
//
// Contrarily to the above events, these entities must have some kind of
typedef dyno::tracked_entity<
    dyno::on_creation<
        dyno::record<dyno::call_stack>
    >,
    dyno::on_destruction<
        dyno::do_nothing
    >,
    dyno::generates<
        acquire, release
    >
> tracked_lock;

//////////////////////////////////////////////////////////////////////////////


namespace dyno { namespace events {
    struct lock_acquire;
    struct lock_release;
}}


struct mutex {
    void lock() {
        // ...
        dyno::generate<dyno::events::acquire>();
    }
};

namespace dyno {
    // can we automatically populate this vector with some ugly hacks?
    // for example by using something similar to my concept based overloading
    // technique?
    typedef boost::mpl::vector<...> FRAMEWORKS;

    template <typename Tag>
    void generate() {
        boost::mpl::for_each<FRAMEWORKS>(generate<Tag>);
    }
}

namespace d2 {
    // dyno defines all generic stuff that has to do with locks (and other objects).
    // we define the caracteristics (a.k.a. how to classify) the objects.
    // we basically define what could be described as concepts in a way that
    // we can pattern match.
    namespace events {
        template <typename Recursive, typename Upgradable, typename ReadWrite>
        struct lock;
    }

    // dyno defines generic wrappers applicable to all locks (and other objects)
    namespace wrappers {
        template <typename Wrapped, typename Recursive, typename Upgradable, typename ReadWrite>
        struct lockable : Wrapped {
            using Wrapped::Wrapped;

            void lock() {
                Wrapped::lock();
                dyno::generate<events::lock<Recursive, Upgradable, ReadWrite> >();
            }

            bool try_lock() {
                if (Wrapped::try_lock()) {
                    dyno::generate<events::try_lock_success<Recursive, Upgradable, ReadWrite> >();
                    return true;
                }
                dyno::generate<events::try_lock_failure<Recursive, Upgradable, ReadWrite> >();
                return false;
            }

            void unlock() {
                Wrapped::unlock();
                dyno::generate<events::release<Recursive, Upgradable, ReadWrite> >();
            }
        };
    }

    // and then frameworks use these events to do stuff. it must also be trivial
    // to extend the set of existing events: dyno itself must use that extension
    // mechanism to define the core events it provides.


    // frameworks could also be proto grammars for matching events.
    // we then associate kind-of-transforms to be performed when
    // this or that event is generated. dyno provides some special
    // environment variables corresponding to the attributes of the
    // events of the current implementation.
    struct d2_framework
        : dyno::when</* grammar for matching events */,
            some_action(dyno::_this, dyno::_thread_id, dyno::_env) // list of attributes to pass to that action
        >
    { };

    /* ce n'est peut-être pas intéressant de spécifier les transforms
       comme avec proto, mais l'idée du pattern matching est vraiment
       intéressante. à la place d'avoir une forme en when<...> comme
       en haut, on pourrait grouper les grammaires à matcher dans un
       listens_to<...> et puis grouper les actions à faire lors d'un
       match dans une autre structure.
    */

    typedef dyno::framework<
        // use pattern matching (a complete proto grammar?) for determining
        // the events to listen to? we could listen to events with some
        // caracteristics while ignoring events with some other caracteristics,
        // and perform different actions based on those caracteristics.
        //
        // note: events could have a lot of caracteristics describing
        //       them. for example, necessary caracteristics for lock
        //       acquires would be whether it is an upgrade, a read/write
        //       lock and so on.
        dyno::listens_to<
            dyno::events::lock_acquire<dyno::recursive>,
            dyno::events::lock_release<dyno::_>,
            dyno::events::lock_acquire<std::mutex> // we could go down to per-type granularity
        >,
        dyno::listener<d2_listener>
    > d2_framework;

    // statically registers the framework to the dyno::FRAMEWORKS vector.
#ifdef D2_ENABLED
    DYNO_REGISTER_FRAMEWORK(d2_framework)
#endif

    // another way of doing it would be to only specify what's really needed:
    // a visitor-like interface. using expression SFINAE, we could then detect
    // whether a framework has a method for handling an event (using pattern
    // matching). that would probably be the most concise way of doing things.
    struct d2_framework {
        // define a property that every lock has (maybe?)
        struct properties_of<any_lock> {
            properties_of() { lock_id = get_new_unique_lock_id(); }
            unsigned lock_id;
        };

        d2_framework() {
            // called during static initialization
        }

        template <typename Event>
        void operator()(dyno::events::lock_acquire<dyno::recursive>, Event const& event) const {
            getattr<thread_id>(event);
            getattr<lock_id>(event);
        }

        template <typename Event>
        void operator()(dyno::events::lock_release<dyno::_>, Event const& event) const {

        }
    };
}
